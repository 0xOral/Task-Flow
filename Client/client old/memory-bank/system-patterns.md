# System Patterns - Student Management System Frontend

## Architecture Patterns

### üèóÔ∏è Component-Based Architecture
**Pattern**: Hierarchical Component Structure with Composition
**Implementation**: React functional components with hooks

```
Application Root
‚îú‚îÄ‚îÄ Providers (Redux, Toast)
‚îú‚îÄ‚îÄ Layout Components (Navigation, Footer)
‚îú‚îÄ‚îÄ Page Components (Students, Login)
‚îú‚îÄ‚îÄ Feature Components (StudentCard, Pagination)
‚îî‚îÄ‚îÄ UI Primitives (Button, Input, Card)
```

**Benefits**:
- Reusability across different pages
- Clear separation of concerns
- Easy testing and maintenance
- Consistent user experience

### üîÑ State Management Pattern
**Pattern**: Redux Toolkit with RTK Query
**Implementation**: Centralized store with feature-based slices

```typescript
// Store Structure
{
  api: {
    queries: {
      getStudents: { data, isLoading, error },
      getStudent: { data, isLoading, error }
    },
    mutations: {
      login: { isLoading, error }
    }
  }
}
```

**Key Characteristics**:
- **Server State**: Managed by RTK Query with automatic caching
- **Client State**: Minimal - mostly UI state kept local
- **Cache Management**: Automatic invalidation with tags
- **Optimistic Updates**: For better user experience

### üé® Design System Pattern
**Pattern**: Atomic Design with Utility-First Styling
**Implementation**: Tailwind CSS with component variants

```
Atoms (Button, Input, Label)
    ‚Üì
Molecules (Card, Form Field)
    ‚Üì  
Organisms (StudentCard, LoginForm)
    ‚Üì
Templates (PageLayout)
    ‚Üì
Pages (StudentsPage, LoginPage)
```

**Implementation Details**:
```typescript
// Component Variant Pattern
const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground",
        destructive: "bg-destructive text-destructive-foreground",
        outline: "border border-input"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8"
      }
    }
  }
)
```

### üîó API Integration Pattern
**Pattern**: Repository Pattern with RTK Query
**Implementation**: Feature-based API slices

```typescript
// API Slice Pattern
export const studentApiSlice = apiSlice.injectEndpoints({
  endpoints: (builder) => ({
    getStudents: builder.query<PaginatedStudentsResponse, number>({
      query: (page) => `/students?page=${page}`,
      providesTags: ['Student']
    }),
    getStudent: builder.query<Student, string>({
      query: (id) => `/students/${id}`,
      providesTags: (result, error, id) => [{ type: 'Student', id }]
    })
  })
});
```

## Code Patterns

### üîß Component Patterns

#### Forward Ref Pattern
**Usage**: All UI components for proper DOM access
```typescript
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("rounded-xl border bg-card", className)}
    {...props}
  />
));
Card.displayName = "Card";
```

**Benefits**:
- Proper ref forwarding for third-party libraries
- Better component composition
- DOM access when needed

#### Compound Component Pattern
**Usage**: Card system with multiple related components
```typescript
// Card.tsx exports multiple related components
export { 
  Card, 
  CardHeader, 
  CardFooter, 
  CardTitle, 
  CardDescription, 
  CardContent 
};

// Usage
<Card>
  <CardHeader>
    <CardTitle>Student Name</CardTitle>
    <CardDescription>University Info</CardDescription>
  </CardHeader>
  <CardContent>
    {/* Student details */}
  </CardContent>
</Card>
```

#### Custom Hook Pattern
**Usage**: Generated by RTK Query for API operations
```typescript
// Auto-generated hooks
const { data, isLoading, error } = useGetStudentsPageQuery(page);
const [login, { isLoading: loginLoading }] = useLoginMutation();
```

### üìù Form Handling Patterns

#### React Hook Form Integration
**Pattern**: Controller-based form handling with validation
```typescript
const form = useForm<loginInput>({
  resolver: zodResolver(loginSchema),
  defaultValues: {
    studentId: "",
    password: ""
  }
});

const onSubmit = async (data: loginInput) => {
  try {
    await login(data).unwrap();
    // Handle success
  } catch (error) {
    // Handle error
  }
};
```

### üéØ Error Handling Patterns

#### API Error Handling
**Pattern**: Centralized error handling with user feedback
```typescript
// In components
if (isError) {
  return <ErrorMessage message="Failed to load students" />;
}

// RTK Query error handling
const handleLogin = async (credentials) => {
  try {
    const result = await login(credentials).unwrap();
    toast.success("Login successful");
  } catch (error) {
    toast.error(error.data?.message || "Login failed");
  }
};
```

#### Loading State Patterns
**Pattern**: Consistent loading indicators
```typescript
// Loading states
if (isLoading) return <LoadingSpinner />;
if (isLoading) return <SkeletonLoader />;

// Conditional rendering
<Button disabled={isLoading}>
  {isLoading ? "Logging in..." : "Login"}
</Button>
```

### üîÑ Data Fetching Patterns

#### Pagination Pattern
**Implementation**: URL-based pagination with state management
```typescript
const [page, setPage] = useState(1);
const { data, isLoading } = useGetStudentsPageQuery(page, {
  refetchOnMountOrArgChange: true
});

// Pagination controls
const renderPageNumbers = () => {
  const pages = [];
  const start = Math.max(1, currentPage - 3);
  const end = Math.min(totalPages, currentPage + 3);
  
  for (let i = start; i <= end; i++) {
    pages.push(
      <Button
        variant={i === currentPage ? "default" : "ghost"}
        onClick={() => setPage(i)}
      >
        {i}
      </Button>
    );
  }
  return pages;
};
```

#### Cache Management Pattern
**Implementation**: Tag-based cache invalidation
```typescript
// Providing cache tags
providesTags: (result, error, page) => 
  result 
    ? [
        ...result.students.map(({ _id }) => 
          ({ type: 'Student' as const, id: _id })
        ),
        { type: 'Student', id: 'LIST' }
      ]
    : [{ type: 'Student', id: 'LIST' }]

// Invalidating cache
invalidatesTags: [{ type: 'Student', id: 'LIST' }]
```

## Documentation Patterns

### üìö Code Documentation Pattern
**Standard**: Comprehensive inline documentation

```typescript
/**
 * Student management page with pagination support
 * 
 * Features:
 * - Paginated student listing
 * - Navigation to individual student details
 * - University quick links
 * - Responsive design
 * 
 * @returns JSX.Element - Rendered students page
 */
const StudentsPage = () => {
  // Implementation
};
```

### üè∑Ô∏è Type Documentation Pattern
**Standard**: Interface documentation with examples

```typescript
/**
 * Student data structure
 * 
 * @interface Student
 * @property {string} _id - Unique identifier
 * @property {string} name - Full name
 * @property {string} email - Contact email
 * @property {University | null} universityId - Associated university
 * @property {Course[]} courses - Enrolled courses
 * @property {string} createdAt - Creation timestamp
 * @property {string} updatedAt - Last update timestamp
 */
interface Student {
  _id: string;
  name: string;
  email: string;
  universityId: {
    _id: string;
    name: string;
  } | null;
  courses: Course[];
  createdAt: string;
  updatedAt: string;
}
```

### üìã Component Documentation Pattern
**Standard**: Props interface with usage examples

```typescript
/**
 * Reusable card component for content display
 * 
 * @example
 * <Card className="max-w-md">
 *   <CardHeader>
 *     <CardTitle>Title</CardTitle>
 *   </CardHeader>
 *   <CardContent>Content here</CardContent>
 * </Card>
 * 
 * @param className - Additional CSS classes
 * @param children - Child components
 * @param ref - Forwarded ref to div element
 */
```

### üîß Configuration Documentation Pattern
**Standard**: Configuration file documentation

```typescript
/**
 * Next.js configuration
 * 
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  /** Enable React strict mode for development */
  reactStrictMode: true,
  
  /** Experimental features */
  experimental: {
    /** Use Turbopack for development builds */
    turbo: true
  }
};
```

## Best Practices Implementation

### üéØ Component Best Practices
1. **Single Responsibility**: Each component has one clear purpose
2. **Composition over Inheritance**: Use component composition
3. **Props Interface**: Always define TypeScript interfaces
4. **Forward Refs**: Use for DOM access and third-party integration
5. **Display Names**: Set for better debugging experience

### üîí Security Patterns
1. **Input Validation**: Zod schemas for all user inputs
2. **XSS Prevention**: React's built-in escaping + validation
3. **Authentication**: JWT tokens with secure storage
4. **API Security**: Credentials included in requests

### ‚ö° Performance Patterns
1. **Code Splitting**: Automatic with Next.js pages
2. **Memoization**: React.memo for heavy components
3. **Lazy Loading**: Dynamic imports for large components
4. **Caching**: RTK Query automatic caching
5. **Bundle Optimization**: Tree shaking and minification

### üß™ Testing Patterns
1. **Component Testing**: Test component behavior, not implementation
2. **API Testing**: Mock RTK Query responses
3. **Integration Testing**: Test user workflows
4. **Accessibility Testing**: Screen reader and keyboard navigation

### üì± Responsive Design Patterns
1. **Mobile First**: Base styles for mobile, enhance for desktop
2. **Breakpoint Usage**: Tailwind's responsive utilities
3. **Flexible Layouts**: Flexbox and Grid for responsive layouts
4. **Touch Targets**: Minimum 44px for mobile interactions

## Anti-Patterns to Avoid

### ‚ùå Component Anti-Patterns
- **Prop Drilling**: Use context or state management instead
- **God Components**: Break down large components
- **Inline Styles**: Use Tailwind classes or CSS modules
- **Direct DOM Manipulation**: Use React patterns instead

### ‚ùå State Management Anti-Patterns
- **Duplicate State**: Single source of truth principle
- **Unnecessary Global State**: Keep state as local as possible
- **Mutating State**: Always use immutable updates
- **Over-fetching**: Use specific queries for specific data needs

### ‚ùå Performance Anti-Patterns
- **Unnecessary Re-renders**: Use React.memo and useMemo appropriately
- **Large Bundle Sizes**: Code split and lazy load
- **Blocking Operations**: Use async patterns
- **Memory Leaks**: Clean up effects and subscriptions