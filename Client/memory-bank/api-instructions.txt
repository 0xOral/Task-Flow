*
üìò Comprehensive API & Frontend Architecture Guide for LMS Project
By Ahmed - Performance-Optimized & Scalable Version

üéØ Goal:
This document provides a complete architectural plan and implementation map for a Learning Management System (LMS) frontend. It covers 27 endpoints, a high-performance data-fetching strategy using React Query and Axios, and a robust role-based access control (RBAC) system.

=======================================================================
üèõÔ∏è SECTION 1: CORE ARCHITECTURE PRINCIPLES
=======================================================================

This architecture ensures separation of concerns, scalability, and maximum performance.

-----------------------------------------------------------------------
üìÅ 1.1 Enhanced Folder Structure

- lib/
  - axios/
    - axiosInstance.ts      // Centralized, configured Axios instance with interceptors
  - api/
    - <resource>.api.ts     // Pure Axios request functions per resource (e.g., courses.api.ts)
  - permissions.ts          // Core logic for role-based permissions
- hooks/
  - api/
    - use<Resource>.ts      // React Query hooks per resource (e.g., useCourses.ts)
  - useAuth.ts              // Hook to get current user's auth status and role
  - useCan.ts               // Hook to check user permissions for specific actions
- types/
  - api.ts                  // All API-related TypeScript types and interfaces
- components/
  - shared/
    - wrappers/
      - CanAccess.tsx       // Wrapper component to conditionally render UI based on permissions

-----------------------------------------------------------------------
üß± 1.2 Axios Instance (lib/axios/axiosInstance.ts)

- **Centralization**: A single instance for all API calls (e.g., `baseURL: http://localhost:5000/api`).
- **Request Interceptor**: Automatically attaches the auth token to headers.
- **Response Interceptor**: Handles global errors like 401 Unauthorized for token refresh or logout.
- **Configuration**: Standardized timeout, headers, and error formatting.

-----------------------------------------------------------------------
üìå 1.3 API Layer (lib/api/*.api.ts)

- **Purpose**: Contains raw, framework-agnostic Axios functions.
- **Structure**: One file per resource (e.g., `courses.api.ts`, `students.api.ts`).
- **Rules**:
  - Exposes functions like `getAllCourses`, `getCourseById`, `createCourse`.
  - No React code or hooks are allowed in this layer.
  - Functions return the full Axios promise: `Promise<AxiosResponse<T>>`.

```typescript
// Example: lib/api/courses.api.ts
import { axiosInstance } from '@/lib/axios/axiosInstance';
import { Course, PaginatedResponse, CoursesQueryParams } from '@/types/api';
import { AxiosResponse } from 'axios';

export const getAllCourses = (params?: CoursesQueryParams): Promise<AxiosResponse<PaginatedResponse<Course>>> => {
  return axiosInstance.get('/courses', { params });
};
.
Text
ü™ù 1.4 React Query Hooks Layer (hooks/api/use<Resource>.ts)
Purpose: Wraps API functions with React Query's useQuery and useMutation.
Structure: One file per resource, corresponding to the API layer (e.g., useCourses.ts).
Key Features:
useQuery: For GET requests, with strategic caching, staleTime, and select for data transformation.
useMutation: For POST, PATCH, DELETE, handling optimistic updates and cache invalidation.
Query Keys: A structured key system for precise cache control.
Generated typescript
// Example: hooks/api/useCourses.ts
import * as coursesApi from '@/lib/api/courses.api';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Structured Query Keys
const courseKeys = {
  all: ['courses'] as const,
  lists: (params: any) => [...courseKeys.all, 'list', params] as const,
  details: (id: string) => [...courseKeys.all, 'detail', id] as const,
};

// Hook for fetching a list of courses
export const useCoursesQuery = (params: any) => {
  return useQuery({
    queryKey: courseKeys.lists(params),
    queryFn: () => coursesApi.getAllCourses(params),
    select: (data) => data.data, // Automatically extract data
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

// Hook for creating a course
export const useCreateCourseMutation = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (newCourseData) => coursesApi.createCourse(newCourseData),
    onSuccess: () => {
      // Invalidate all queries that start with ['courses', 'list']
      queryClient.invalidateQueries({ queryKey: courseKeys.lists({}) });
    },
    // Optional: Add optimistic updates here
  });
};
.
TypeScript
‚ö° 1.5 Global QueryClient Configuration
Set up performance-optimized defaults for your entire application in your main _app.tsx or layout component.
Generated typescript
// Example: _app.tsx or main component
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,       // 5 minutes
      cacheTime: 15 * 60 * 1000,      // 15 minutes (longer than staleTime)
      refetchOnWindowFocus: false,    // Prevents unnecessary refetches
      retry: 2,                       // Retry failed queries twice
    },
    mutations: {
      retry: 1,
    },
  },
});

function MyApp({ Component, pageProps }) {
  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
.
TypeScript
=======================================================================
üîê SECTION 2: ROLE-BASED ACCESS CONTROL (RBAC)
This system provides a clean, scalable way to manage frontend UI and actions based on user roles.
‚úÖ 2.1 Core Permission Logic (lib/permissions.ts)
A central function maps roles to their allowed actions.
Generated typescript
type Role = 'student' | 'teacher' | 'admin' | 'super-admin';
type Action = 'view' | 'create' | 'edit' | 'delete' | 'manage-users';

const rolePermissions: Record<Role, Action[]> = {
  student: ['view'],
  teacher: ['view', 'create', 'edit'],
  admin: ['view', 'create', 'edit', 'delete'],
  'super-admin': ['view', 'create', 'edit', 'delete', 'manage-users'],
};

export function can(role: Role, action: Action): boolean {
  if (!role) return false;
  return rolePermissions[role]?.includes(action) ?? false;
}
.
TypeScript
‚úÖ 2.2 Auth & Permission Hooks (hooks/useAuth.ts & hooks/useCan.ts)
These hooks provide easy access to the user's role and permission status.
Generated typescript
// hooks/useAuth.ts
import Cookies from 'js-cookie';
export function useAuth() {
  const role = Cookies.get('role') as Role; // Assume role is stored in a cookie
  return { role, isAuthenticated: !!Cookies.get('token') };
}

// hooks/useCan.ts
import { useAuth } from './useAuth';
import { can } from '@/lib/permissions';
import { Action } from '@/lib/permissions';

export function useCan(action: Action) {
  const { role } = useAuth();
  return can(role, action);
}
.
TypeScript
‚úÖ 2.3 UI Wrapper Component (components/shared/wrappers/CanAccess.tsx)
Conditionally render components without cluttering your JSX with logic.
Generated typescript
import { ReactNode } from 'react';
import { useCan } from '@/hooks/useCan';
import { Action } from '@/lib/permissions';

export function CanAccess({ action, children }: { action: Action; children: ReactNode }) {
  const isAllowed = useCan(action);
  return isAllowed ? <>{children}</> : null;
}

// Usage Example:
<CanAccess action="edit">
  <EditButton />
</CanAccess>
.
TypeScript
=======================================================================
üìä SECTION 3: ARCHITECTURE SUMMARY & BENEFITS
Total Endpoints Documented: 27
Endpoint Breakdown:
Courses: 5 (Full CRUD + List)
Students: 5 (Full CRUD + List)
Teachers: 5 (Full CRUD + List)
Admin: 4 (CRUD without delete)
Universities: 5 (Full CRUD + List)
Colleges: 5 (Full CRUD + List)
Departments: 2 (Read-only)
üöÄ Key Benefits:
Superior Performance: Achieved through intelligent caching, staleTime, background refetching, and optimistic updates.
Enhanced User Experience (UX): Instant UI feedback from mutations, minimal loading states, and robust error handling.
Improved Developer Experience (DX): Predictable state management, clear separation of concerns, TypeScript safety, and powerful DevTools for debugging.
Scalability & Maintainability: The pattern-based approach makes adding or modifying endpoints simple and consistent across the application.
Memory Efficiency: React Query's automatic garbage collection cleans up unused cache data, preventing memory leaks.
Robustness: Global error handling, request interceptors, and built-in retry mechanisms create a more resilient application.
END OF COMPREHENSIVE GUIDE ‚úÖ
*/